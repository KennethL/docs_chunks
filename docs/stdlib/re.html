<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.21.2">
    <meta name="project" content="stdlib v22.1.4">
    <title>re â€” stdlib v22.1.4</title>
    <link rel="stylesheet" href="dist/erlang-94f16191f0a724ab8055.css" />
    <script src="dist/sidebar_items-fd3ce01463.js"></script>
      <script src="docs_config.js"></script>
    <script async src="dist/app-a9f3287e74588dddabf3.js"></script>
  </head>
  <body data-type="modules">
    <script>try { if(localStorage.getItem('night-mode') === 'true') document.body.className += ' night-mode'; } catch (e) { }</script>
<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button">
      <span class="icon-cross" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" id="search-list" class="search-input" placeholder="Search..." aria-label="Search" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="array.html" class="sidebar-projectName">
stdlib      </a>
      <h2 class="sidebar-projectVersion">
        v22.1.4
      </h2>
    </div>
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

      <li><a id="modules-list" href="#full-list">Modules</a></li>


  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

      <h1>
        <small class="app-vsn">stdlib v22.1.4</small>
re      </h1>


        <section id="moduledoc">
<p> This module contains regular expression matching functions for strings and binaries.</p>
<p> The regular expression syntax and semantics resemble that of Perl.</p>
<p> The matching algorithms of the library are based on the PCRE library, but not all of the PCRE library is interfaced and some parts of the library go beyond what PCRE offers. Currently PCRE version 8.40 (release date 2017-01-11) is used. The sections of the PCRE documentation that are relevant to this module are included here.</p>
<p>  The Erlang literal syntax for strings uses the &quot;\&quot; (backslash) character as an escape code. You need to escape backslashes in literal strings, both in your code and in the shell, with an extra backslash, that is, &quot;\&quot;.</p>
        </section>

        <section id="summary" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#summary">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
            Summary
          </h1>
  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile/1">compile/1</a>
  </div>
    <div class="summary-synopsis"><p> The same as <code class="inline">compile(``Regexp``,[])</code></p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#compile/2">compile/2</a>
  </div>
    <div class="summary-synopsis"><p> Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to <a href="#run/2"><code class="inline">run/2</code></a> and <a href="#run/3"><code class="inline">run/3</code></a>.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#inspect/2">inspect/2</a>
  </div>
    <div class="summary-synopsis"><p> Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is <code class="inline">namelist</code>, which returns the tuple <code class="inline">{namelist, [binary()]}</code>, containing the names of all (unique) named subpatterns in the regular expression. For example</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#replace/3">replace/3</a>
  </div>
    <div class="summary-synopsis"><p> Same as <code class="inline">replace(``Subject``, ``RE``, ``Replacement``, [])</code>.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#replace/4">replace/4</a>
  </div>
    <div class="summary-synopsis"><p> Replaces the matched part of the <code class="inline">Subject</code> string with the contents of <code class="inline">Replacement</code>.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#run/2">run/2</a>
  </div>
    <div class="summary-synopsis"><p> Same as <code class="inline">run(``Subject``,``RE``,[])</code>.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#run/3">run/3</a>
  </div>
    <div class="summary-synopsis"><p> Executes a regular expression matching, and returns <code class="inline">match/{match, ``Captured``}</code> or <code class="inline">nomatch</code>. The regular expression can be specified either as <code class="inline">iodata()</code> in which case it is automatically compiled (as by <a href="#compile/2"><code class="inline">compile/2</code></a>) and executed, or as a precompiled <code class="inline">mp()</code> in which case it is executed against the subject directly.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/2">split/2</a>
  </div>
    <div class="summary-synopsis"><p> Same as <code class="inline">split(``Subject``, ``RE``, [])</code>.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#split/3">split/3</a>
  </div>
    <div class="summary-synopsis"><p> Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output.</p></div>
</div>
<div class="summary-row">
  <div class="summary-signature">
    <a href="#version/0">version/0</a>
  </div>
    <div class="summary-synopsis"><p> The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</p></div>
</div>
  </div>
        </section>

        <section id="functions" class="details-list">
          <h1 class="section-heading">
            <a class="hover-link" href="#functions">
              <span class="icon-link" aria-hidden="true"></span>
              <span class="sr-only">Link to this section</span>
            </a>
Functions          </h1>
          <div class="functions-list">
<section class="detail" id="compile/1">
  <div class="detail-header">
    <a href="#compile/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile/1</h1>
      <div class="specs">
          <pre>compile(Regexp) -> {ok, MP} | {error, ErrSpec}
           when
               Regexp :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>(),
               MP :: mp(),
               ErrSpec ::
                   {ErrString :: string(),
                    Position :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> The same as <code class="inline">compile(``Regexp``,[])</code></p>
  </section>
</section>
<section class="detail" id="compile/2">
  <div class="detail-header">
    <a href="#compile/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">compile/2</h1>
      <div class="specs">
          <pre>compile(Regexp, Options) -> {ok, MP} | {error, ErrSpec}
           when
               Regexp :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
               Options :: [Option],
               Option :: compile_option(),
               MP :: mp(),
               ErrSpec ::
                   {ErrString :: string(),
                    Position :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Compiles a regular expression, with the syntax described below, into an internal format to be used later as a parameter to <a href="#run/2"><code class="inline">run/2</code></a> and <a href="#run/3"><code class="inline">run/3</code></a>.</p>
<p> Compiling the regular expression before matching is useful if the same expression is to be used in matching against multiple subjects during the lifetime of the program. Compiling once and executing many times is far more efficient than compiling each time one wants to match.</p>
<p> When option <code class="inline">unicode</code> is specified, the regular expression is to be specified as a valid Unicode <code class="inline">charlist()</code>, otherwise as any valid <code class="inline">iodata()</code>.</p>
<p>  Options:</p>
<p>  <code class="inline">unicode</code>   *  The regular expression is specified as a Unicode <code class="inline">charlist()</code> and the resulting regular expression code is to be run against a valid Unicode <code class="inline">charlist()</code> subject. Also consider option <code class="inline">ucp</code> when using Unicode characters.</p>
<p>  <code class="inline">anchored</code>   *  The pattern is forced to be &quot;anchored&quot;, that is, it is constrained to match only at the first matching point in the string that is searched (the &quot;subject string&quot;). This effect can also be achieved by appropriate constructs in the pattern itself.</p>
<p>  <code class="inline">caseless</code>   *  Letters in the pattern match both uppercase and lowercase letters. It is equivalent to Perl option <code class="inline">/i</code> and can be changed within a pattern by a <code class="inline">(?i)</code> option setting. Uppercase and lowercase letters are defined as in the ISO 8859-1 character set.</p>
<p>  <code class="inline">dollar_endonly</code>   *  A dollar metacharacter in the pattern matches only at the end of the subject string. Without this option, a dollar also matches immediately before a newline at the end of the string (but not before any other newlines). This option is ignored if option <code class="inline">multiline</code> is specified. There is no equivalent option in Perl, and it cannot be set within a pattern.</p>
<p>  <code class="inline">dotall</code>   *  A dot in the pattern matches all characters, including those indicating newline. Without it, a dot does not match when the current position is at a newline. This option is equivalent to Perl option <code class="inline">/s</code> and it can be changed within a pattern by a <code class="inline">(?s)</code> option setting. A negative class, such as <code class="inline">[^a]</code>, always matches newline characters, independent of the setting of this option.</p>
<p>  <code class="inline">extended</code>   *  If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as <code class="inline">(?&gt;</code> that introduce various parenthesized subpatterns, nor within a numerical quantifier such as <code class="inline">{1,3}</code>. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness. </p>
<p> White space did not used to include the VT character (code 11), because Perl did not treat this character as white space. However, Perl changed at release 5.18, so PCRE followed at release 8.34, and VT is now treated as white space. </p>
<p> This also causes characters between an unescaped # outside a character class and the next newline, inclusive, to be ignored. This is equivalent to Perl&#39;s <code class="inline">/x</code> option, and it can be changed within a pattern by a <code class="inline">(?x)</code> option setting. </p>
<p> With this option, comments inside complicated patterns can be included. However, notice that this applies only to data characters. Whitespace characters can never appear within special character sequences in a pattern, for example within sequence <code class="inline">(?(</code> that introduces a conditional subpattern.</p>
<p>  <code class="inline">firstline</code>   *  An unanchored pattern is required to match before or at the first newline in the subject string, although the matched text can continue over the newline.</p>
<p>  <code class="inline">multiline</code>   *  By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (<code class="inline">^</code>) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (<code class="inline">$</code>) matches only at the end of the string, or before a terminating newline (unless option <code class="inline">dollar_endonly</code> is specified). This is the same as in Perl.</p>
<p> When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option <code class="inline">/m</code> and can be changed within a pattern by a <code class="inline">(?m)</code> option setting. If there are no newlines in a subject string, or no occurrences of <code class="inline">^</code> or <code class="inline">$</code> in a pattern, setting <code class="inline">multiline</code> has no effect.</p>
<p>  <code class="inline">no_auto_capture</code>   *  Disables the use of numbered capturing parentheses in the pattern. Any opening parenthesis that is not followed by <code class="inline">?</code> behaves as if it is followed by <code class="inline">?:</code>. Named parentheses can still be used for capturing (and they acquire numbers in the usual way). There is no equivalent option in Perl.</p>
<p>  <code class="inline">dupnames</code>   *  Names used to identify capturing subpatterns need not be unique. This can be helpful for certain types of pattern when it is known that only one instance of the named subpattern can ever be matched. More details of named subpatterns are provided below.</p>
<p>  <code class="inline">ungreedy</code>   *  Inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by &quot;?&quot;. It is not compatible with Perl. It can also be set by a <code class="inline">(?U)</code> option setting within the pattern.</p>
<p>  <code class="inline">{newline, NLSpec}</code>   *  Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</p>
<p>  <code class="inline">cr</code>   *  Newline is indicated by a single character <code class="inline">cr</code> (ASCII 13).</p>
<p>  <code class="inline">lf</code>   *  Newline is indicated by a single character LF (ASCII 10), the default.</p>
<p>  <code class="inline">crlf</code>   *  Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</p>
<p>  <code class="inline">anycrlf</code>   *  Any of the three preceding sequences is to be recognized.</p>
<p>  <code class="inline">any</code>   *  Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</p>
<pre><code class="nohighlight makeup elixir"><span class="err">`</span><span class="n">bsr_anycrlf</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w">  </span><span class="nc">Specifies</span><span class="w"> </span><span class="n">specifically</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="err">\</span><span class="nc">R</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">CR</span><span class="p">,</span><span class="w"> </span><span class="nc">LF</span><span class="p">,</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="nc">CRLF</span><span class="w"> </span><span class="n">sequences</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">Unicode</span><span class="o">-</span><span class="n">specific</span><span class="w"> </span><span class="n">newline</span><span class="w"> </span><span class="n">characters</span><span class="o">.</span></code></pre>
<p>  <code class="inline">bsr_unicode</code>   *  Specifies specifically that \R is to match all the Unicode newline characters (including CRLF, and so on, the default).</p>
<p>  <code class="inline">no_start_optimize</code>   <em>  Disables optimization that can malfunction if &quot;Special start-of-pattern items&quot; are present in the regular expression. A typical example would be when matching &quot;DEFABC&quot; against &quot;(</em>COMMIT)ABC&quot;, where the start optimization of PCRE would skip the subject up to &quot;A&quot; and never realize that the (*COMMIT) instruction is to have made the matching fail. This option is only relevant if you use &quot;start-of-pattern items&quot;, as discussed in section PCRE Regular Expression Details.</p>
<p>  <code class="inline">ucp</code>   *  Specifies that Unicode character properties are to be used when resolving \B, \b, \D, \d, \S, \s, \W and \w. Without this flag, only ISO Latin-1 properties are used. Using Unicode properties hurts performance, but is semantically correct when working with Unicode characters beyond the ISO Latin-1 range.</p>
<p>  <code class="inline">never_utf</code>   <em>  Specifies that the (</em>UTF) and/or (*UTF8) &quot;start-of-pattern items&quot; are forbidden. This flag cannot be combined with option <code class="inline">unicode</code>. Useful if ISO Latin-1 patterns from an external source are to be compiled.</p>
  </section>
</section>
<section class="detail" id="inspect/2">
  <div class="detail-header">
    <a href="#inspect/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">inspect/2</h1>
      <div class="specs">
          <pre>inspect(MP, Item) -> {namelist, [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()]}
           when MP :: mp(), Item :: namelist.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Takes a compiled regular expression and an item, and returns the relevant data from the regular expression. The only supported item is <code class="inline">namelist</code>, which returns the tuple <code class="inline">{namelist, [binary()]}</code>, containing the names of all (unique) named subpatterns in the regular expression. For example:</p>
<pre><code class="nohighlight makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9826815661-1">{</span><span class="n">ok</span><span class="p">,</span><span class="nc">MP</span><span class="p" data-group-id="9826815661-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="ss">:compile</span><span class="p" data-group-id="9826815661-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="9826815661-2">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9826815661-3">{</span><span class="n">ok</span><span class="p">,</span><span class="p" data-group-id="9826815661-4">{</span><span class="n">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="9826815661-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">...</span><span class="p" data-group-id="9826815661-5">&gt;&gt;</span><span class="p" data-group-id="9826815661-4">}</span><span class="p" data-group-id="9826815661-3">}</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="ss">:inspect</span><span class="p" data-group-id="9826815661-6">(</span><span class="nc">MP</span><span class="p">,</span><span class="n">namelist</span><span class="p" data-group-id="9826815661-6">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9826815661-7">{</span><span class="n">namelist</span><span class="p">,</span><span class="p" data-group-id="9826815661-8">[</span><span class="p" data-group-id="9826815661-9">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="9826815661-9">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9826815661-10">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="9826815661-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9826815661-11">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="9826815661-11">&gt;&gt;</span><span class="p" data-group-id="9826815661-8">]</span><span class="p" data-group-id="9826815661-7">}</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9826815661-12">{</span><span class="n">ok</span><span class="p">,</span><span class="nc">MPD</span><span class="p" data-group-id="9826815661-12">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="ss">:compile</span><span class="p" data-group-id="9826815661-13">(</span><span class="s">&quot;(?&lt;C&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p">,</span><span class="p" data-group-id="9826815661-14">[</span><span class="n">dupnames</span><span class="p" data-group-id="9826815661-14">]</span><span class="p" data-group-id="9826815661-13">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9826815661-15">{</span><span class="n">ok</span><span class="p">,</span><span class="p" data-group-id="9826815661-16">{</span><span class="n">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="9826815661-17">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">...</span><span class="p" data-group-id="9826815661-17">&gt;&gt;</span><span class="p" data-group-id="9826815661-16">}</span><span class="p" data-group-id="9826815661-15">}</span><span class="w">
</span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="ss">:inspect</span><span class="p" data-group-id="9826815661-18">(</span><span class="nc">MPD</span><span class="p">,</span><span class="n">namelist</span><span class="p" data-group-id="9826815661-18">)</span><span class="o">.</span><span class="w">                                   
</span><span class="p" data-group-id="9826815661-19">{</span><span class="n">namelist</span><span class="p">,</span><span class="p" data-group-id="9826815661-20">[</span><span class="p" data-group-id="9826815661-21">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="9826815661-21">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9826815661-22">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="9826815661-22">&gt;&gt;</span><span class="p" data-group-id="9826815661-20">]</span><span class="p" data-group-id="9826815661-19">}</span></code></pre>
<p> Notice in the second example that the duplicate name only occurs once in the returned list, and that the list is in alphabetical order regardless of where the names are positioned in the regular expression. The order of the names is the same as the order of captured subexpressions if <code class="inline">{capture, all_names}</code> is specified as an option to <a href="#run/3"><code class="inline">run/3</code></a>. You can therefore create a name-to-value mapping from the result of <a href="#run/3"><code class="inline">run/3</code></a> like this:</p>
<pre><code class="nohighlight makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9799329588-1">{</span><span class="n">ok</span><span class="p">,</span><span class="nc">MP</span><span class="p" data-group-id="9799329588-1">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="ss">:compile</span><span class="p" data-group-id="9799329588-2">(</span><span class="s">&quot;(?&lt;A&gt;A)|(?&lt;B&gt;B)|(?&lt;C&gt;C)&quot;</span><span class="p" data-group-id="9799329588-2">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9799329588-3">{</span><span class="n">ok</span><span class="p">,</span><span class="p" data-group-id="9799329588-4">{</span><span class="n">re_pattern</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="w">
                </span><span class="p" data-group-id="9799329588-5">&lt;&lt;</span><span class="mi">69</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">67</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">119</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="w">
                  </span><span class="mi">255</span><span class="p">,</span><span class="mi">255</span><span class="p">,</span><span class="n">...</span><span class="p" data-group-id="9799329588-5">&gt;&gt;</span><span class="p" data-group-id="9799329588-4">}</span><span class="p" data-group-id="9799329588-3">}</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9799329588-6">{</span><span class="n">namelist</span><span class="p">,</span><span class="w"> </span><span class="nc">N</span><span class="p" data-group-id="9799329588-6">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="ss">:inspect</span><span class="p" data-group-id="9799329588-7">(</span><span class="nc">MP</span><span class="p">,</span><span class="n">namelist</span><span class="p" data-group-id="9799329588-7">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9799329588-8">{</span><span class="n">namelist</span><span class="p">,</span><span class="p" data-group-id="9799329588-9">[</span><span class="p" data-group-id="9799329588-10">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="9799329588-10">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-11">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="9799329588-11">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-12">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="9799329588-12">&gt;&gt;</span><span class="p" data-group-id="9799329588-9">]</span><span class="p" data-group-id="9799329588-8">}</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="p" data-group-id="9799329588-13">{</span><span class="n">match</span><span class="p">,</span><span class="nc">L</span><span class="p" data-group-id="9799329588-13">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="9799329588-14">(</span><span class="s">&quot;AA&quot;</span><span class="p">,</span><span class="nc">MP</span><span class="p">,</span><span class="p" data-group-id="9799329588-15">[</span><span class="p" data-group-id="9799329588-16">{</span><span class="n">capture</span><span class="p">,</span><span class="n">all_names</span><span class="p">,</span><span class="n">binary</span><span class="p" data-group-id="9799329588-16">}</span><span class="p" data-group-id="9799329588-15">]</span><span class="p" data-group-id="9799329588-14">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9799329588-17">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="9799329588-18">[</span><span class="p" data-group-id="9799329588-19">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="9799329588-19">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-20">&lt;&lt;</span><span class="p" data-group-id="9799329588-20">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-21">&lt;&lt;</span><span class="p" data-group-id="9799329588-21">&gt;&gt;</span><span class="p" data-group-id="9799329588-18">]</span><span class="p" data-group-id="9799329588-17">}</span><span class="w">
</span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="nc">NameMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lists</span><span class="ss">:zip</span><span class="p" data-group-id="9799329588-22">(</span><span class="nc">N</span><span class="p">,</span><span class="nc">L</span><span class="p" data-group-id="9799329588-22">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="9799329588-23">[</span><span class="p" data-group-id="9799329588-24">{</span><span class="p" data-group-id="9799329588-25">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="9799329588-25">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-26">&lt;&lt;</span><span class="s">&quot;A&quot;</span><span class="p" data-group-id="9799329588-26">&gt;&gt;</span><span class="p" data-group-id="9799329588-24">}</span><span class="p">,</span><span class="p" data-group-id="9799329588-27">{</span><span class="p" data-group-id="9799329588-28">&lt;&lt;</span><span class="s">&quot;B&quot;</span><span class="p" data-group-id="9799329588-28">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-29">&lt;&lt;</span><span class="p" data-group-id="9799329588-29">&gt;&gt;</span><span class="p" data-group-id="9799329588-27">}</span><span class="p">,</span><span class="p" data-group-id="9799329588-30">{</span><span class="p" data-group-id="9799329588-31">&lt;&lt;</span><span class="s">&quot;C&quot;</span><span class="p" data-group-id="9799329588-31">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="9799329588-32">&lt;&lt;</span><span class="p" data-group-id="9799329588-32">&gt;&gt;</span><span class="p" data-group-id="9799329588-30">}</span><span class="p" data-group-id="9799329588-23">]</span></code></pre>
  </section>
</section>
<section class="detail" id="replace/3">
  <div class="detail-header">
    <a href="#replace/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">replace/3</h1>
      <div class="specs">
          <pre>replace(Subject, RE, Replacement) -> <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>()
           when
               Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
               RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>(),
               Replacement :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>().
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Same as <code class="inline">replace(``Subject``, ``RE``, ``Replacement``, [])</code>.</p>
  </section>
</section>
<section class="detail" id="replace/4">
  <div class="detail-header">
    <a href="#replace/4" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">replace/4</h1>
      <div class="specs">
          <pre>replace(Subject, RE, Replacement, Options) ->
           <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>()
           when
               Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
               RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
               Replacement :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
               Options :: [Option],
               Option ::
                   anchored | global | notbol | noteol |
                   notempty | notempty_atstart |
                   {offset, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                   {newline, NLSpec} |
                   bsr_anycrlf |
                   {match_limit, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                   {match_limit_recursion, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                   bsr_unicode |
                   {return, ReturnType} |
                   CompileOpt,
               ReturnType :: iodata | list | binary,
               CompileOpt :: compile_option(),
               NLSpec :: cr | crlf | lf | anycrlf | any.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Replaces the matched part of the <code class="inline">Subject</code> string with the contents of <code class="inline">Replacement</code>.</p>
<p> The permissible options are the same as for <a href="#run/3"><code class="inline">run/3</code></a>, except that option<code class="inline">capture</code> is not allowed. Instead a <code class="inline">{return, ``ReturnType``}</code> is present. The default return type is <code class="inline">iodata</code>, constructed in a way to minimize copying. The <code class="inline">iodata</code> result can be used directly in many I/O operations. If a flat <code class="inline">list()</code> is desired, specify <code class="inline">{return, list}</code>. If a binary is desired, specify <code class="inline">{return, binary}</code>.</p>
<p> As in function <a href="#run/3"><code class="inline">run/3</code></a>, an <code class="inline">mp()</code> compiled with option <code class="inline">unicode</code> requires <code class="inline">Subject</code> to be a Unicode <code class="inline">charlist()</code>. If compilation is done implicitly and the <code class="inline">unicode</code> compilation option is specified to this function, both the regular expression and <code class="inline">Subject</code> are to specified as valid Unicode <code class="inline">charlist()</code>s.</p>
<p> The replacement string can contain the special character <code class="inline">&amp;</code>, which inserts the whole matching expression in the result, and the special sequence <code class="inline">\</code>N (where N is an integer &gt; 0), <code class="inline">\g</code>N, or <code class="inline">\g{</code>N<code class="inline">}</code>, resulting in the subexpression number N, is inserted in the result. If no subexpression with that number is generated by the regular expression, nothing is inserted.</p>
<p> To insert an &amp; or a \ in the result, precede it with a . Notice that Erlang already gives a special meaning to \ in literal strings, so a single \ must be written as <code class="inline">&quot;\\&quot;</code> and therefore a double \ as <code class="inline">&quot;\\\\&quot;</code>.</p>
<p> Example:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:replace</span><span class="p" data-group-id="0752540949-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="0752540949-2">[</span><span class="p" data-group-id="0752540949-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="0752540949-3">}</span><span class="p" data-group-id="0752540949-2">]</span><span class="p" data-group-id="0752540949-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;ab[c]d&quot;</span></code></pre>
<p> while</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:replace</span><span class="p" data-group-id="2167583585-1">(</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;[</span><span class="se">\\</span><span class="s">&amp;]&quot;</span><span class="p">,</span><span class="p" data-group-id="2167583585-2">[</span><span class="p" data-group-id="2167583585-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="2167583585-3">}</span><span class="p" data-group-id="2167583585-2">]</span><span class="p" data-group-id="2167583585-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;ab[&amp;]d&quot;</span></code></pre>
<p> As with <a href="#run/3"><code class="inline">run/3</code></a>, compilation errors raise the <code class="inline">badarg</code> exception. <a href="#compile/2"><code class="inline">compile/2</code></a> can be used to get more information about the error.</p>
  </section>
</section>
<section class="detail" id="run/2">
  <div class="detail-header">
    <a href="#run/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">run/2</h1>
      <div class="specs">
          <pre>run(Subject, RE) -> {match, Captured} | nomatch
       when
           Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
           RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>(),
           Captured :: [CaptureData],
           CaptureData :: {<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()}.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Same as <code class="inline">run(``Subject``,``RE``,[])</code>.</p>
  </section>
</section>
<section class="detail" id="run/3">
  <div class="detail-header">
    <a href="#run/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">run/3</h1>
      <div class="specs">
          <pre>run(Subject, RE, Options) ->
       {match, Captured} | match | nomatch | {error, ErrType}
       when
           Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
           RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
           Options :: [Option],
           Option ::
               anchored | global | notbol | noteol | notempty |
               notempty_atstart | report_errors |
               {offset, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
               {match_limit, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
               {match_limit_recursion, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
               {newline, NLSpec :: nl_spec()} |
               bsr_anycrlf | bsr_unicode |
               {capture, ValueSpec} |
               {capture, ValueSpec, Type} |
               CompileOpt,
           Type :: index | list | binary,
           ValueSpec ::
               all | all_but_first | all_names | first | none |
               ValueList,
           ValueList :: [ValueID],
           ValueID :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>() | string() | <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">atom</a>(),
           CompileOpt :: compile_option(),
           Captured :: [CaptureData] | [[CaptureData]],
           CaptureData ::
               {<a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>(), <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">integer</a>()} |
               ListConversionData |
               <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>(),
           ListConversionData ::
               string() |
               {error, string(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()} |
               {incomplete, string(), <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>()},
           ErrType ::
               match_limit | match_limit_recursion |
               {compile, CompileErr},
           CompileErr ::
               {ErrString :: string(),
                Position :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()}.
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Executes a regular expression matching, and returns <code class="inline">match/{match, ``Captured``}</code> or <code class="inline">nomatch</code>. The regular expression can be specified either as <code class="inline">iodata()</code> in which case it is automatically compiled (as by <a href="#compile/2"><code class="inline">compile/2</code></a>) and executed, or as a precompiled <code class="inline">mp()</code> in which case it is executed against the subject directly.</p>
<p> When compilation is involved, exception <code class="inline">badarg</code> is thrown if a compilation error occurs. Call <a href="#compile/2"><code class="inline">compile/2</code></a> to get information about the location of the error in the regular expression.</p>
<p> If the regular expression is previously compiled, the option list can only contain the following options:</p>
<pre><code class="nohighlight makeup elixir"><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">anchored</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="2258985389-1">{</span><span class="n">capture</span><span class="p">,</span><span class="w"> </span><span class="err">`</span><span class="err">`</span><span class="nc">ValueSpec</span><span class="err">`</span><span class="err">`</span><span class="p" data-group-id="2258985389-1">}</span><span class="o">/</span><span class="p" data-group-id="2258985389-2">{</span><span class="n">capture</span><span class="p">,</span><span class="w">
        </span><span class="err">`</span><span class="err">`</span><span class="nc">ValueSpec</span><span class="err">`</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="err">`</span><span class="err">`</span><span class="nc">Type</span><span class="err">`</span><span class="err">`</span><span class="p" data-group-id="2258985389-2">}</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">global</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="2258985389-3">{</span><span class="n">match_limit</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="2258985389-4">(</span><span class="p" data-group-id="2258985389-4">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="2258985389-3">}</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="2258985389-5">{</span><span class="n">match_limit_recursion</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="2258985389-6">(</span><span class="p" data-group-id="2258985389-6">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="2258985389-5">}</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="2258985389-7">{</span><span class="n">newline</span><span class="p">,</span><span class="w"> </span><span class="err">`</span><span class="err">`</span><span class="nc">NLSpec</span><span class="err">`</span><span class="err">`</span><span class="p" data-group-id="2258985389-7">}</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">notbol</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">notempty</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">notempty_atstart</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">noteol</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="2258985389-8">{</span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">integer</span><span class="p" data-group-id="2258985389-9">(</span><span class="p" data-group-id="2258985389-9">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p" data-group-id="2258985389-8">}</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w"> </span><span class="err">`</span><span class="n">report_errors</span><span class="err">`</span><span class="w">  </span><span class="nc">Otherwise</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">options</span><span class="w"> </span><span class="n">valid</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="p" data-group-id="2258985389-10">[</span><span class="err">`</span><span class="n">compile</span><span class="o">/</span><span class="mi">2</span><span class="err">`</span><span class="p" data-group-id="2258985389-10">]</span><span class="p" data-group-id="2258985389-11">(</span><span class="c1">#compile/2) are also allowed. Options allowed both for compilation and execution of a match, namely `anchored` and `{newline,</span><span class="w">
      </span><span class="err">`</span><span class="err">`</span><span class="nc">NLSpec</span><span class="err">`</span><span class="err">`</span><span class="err">}</span><span class="err">`</span><span class="p">,</span><span class="w"> </span><span class="n">affect</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">execution</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">present</span><span class="w"> </span><span class="n">together</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">precompiled</span><span class="w"> </span><span class="n">regular</span><span class="w"> </span><span class="n">expression</span><span class="o">.</span></code></pre>
<p> If the regular expression was previously compiled with option <code class="inline">unicode</code>, <code class="inline">Subject</code> is to be provided as a valid Unicode <code class="inline">charlist()</code>, otherwise any <code class="inline">iodata()</code> will do. If compilation is involved and option <code class="inline">unicode</code> is specified, both <code class="inline">Subject</code> and the regular expression are to be specified as valid Unicode <code class="inline">charlists()</code>.</p>
<p> <code class="inline">{capture, ``ValueSpec``}/{capture, ``ValueSpec``, ``Type``}</code> defines what to return from the function upon successful matching. The <code class="inline">capture</code> tuple can contain both a value specification, telling which of the captured substrings are to be returned, and a type specification, telling how captured substrings are to be returned (as index tuples, lists, or binaries). The options are described in detail below.</p>
<p> If the capture options describe that no substring capturing is to be done (<code class="inline">{capture, none}</code>), the function returns the single atom <code class="inline">match</code> upon successful matching, otherwise the tuple <code class="inline">{match, ``ValueList``}</code>. Disabling capturing can be done either by specifying <code class="inline">none</code> or an empty list as <code class="inline">ValueSpec</code>.</p>
<p> Option <code class="inline">report_errors</code> adds the possibility that an error tuple is returned. The tuple either indicates a matching error (<code class="inline">match_limit</code> or <code class="inline">match_limit_recursion</code>), or a compilation error, where the error tuple has the format <code class="inline">{error, {compile, ``CompileErr``}}</code>. Notice that if option <code class="inline">report_errors</code> is not specified, the function never returns error tuples, but reports compilation errors as a <code class="inline">badarg</code> exception and failed matches because of exceeded match limits simply as <code class="inline">nomatch</code>.</p>
<p> The following options are relevant for execution:</p>
<p>  <code class="inline">anchored</code>   *  Limits <a href="#run/3"><code class="inline">run/3</code></a> to matching at the first matching position. If a pattern was compiled with <code class="inline">anchored</code>, or turned out to be anchored by virtue of its contents, it cannot be made unanchored at matching time, hence there is no <code class="inline">unanchored</code> option.</p>
<p> <code class="inline">global</code>   *  Implements global (repetitive) search (flag <code class="inline">g</code> in Perl). Each match is returned as a separate <code class="inline">list()</code> containing the specific match and any matching subexpressions (or as specified by option <code class="inline">capture</code>. The <code class="inline">Captured</code> part of the return value is hence a <code class="inline">list()</code> of <code class="inline">list()</code>s when this option is specified.</p>
<p> The interaction of option <code class="inline">global</code> with a regular expression that matches an empty string surprises some users. When option <code class="inline">global</code> is specified, <a href="#run/3"><code class="inline">run/3</code></a> handles empty matches in the same way as Perl: a zero-length match at any point is also retried with options <code class="inline">[anchored, notempty_atstart]</code>. If that search gives a result of length &gt; 0, the result is included. Example:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="5469238297-1">(</span><span class="s">&quot;cat&quot;</span><span class="p">,</span><span class="s">&quot;(|at)&quot;</span><span class="p">,</span><span class="p" data-group-id="5469238297-2">[</span><span class="n">global</span><span class="p" data-group-id="5469238297-2">]</span><span class="p" data-group-id="5469238297-1">)</span><span class="o">.</span></code></pre>
<p> The following matchings are performed:</p>
<p>  At offset <code class="inline">0</code>   *  The regular expression <code class="inline">(|at)</code> first match at the initial position of string <code class="inline">cat</code>, giving the result set <code class="inline">[{0,0},{0,0}]</code> (the second <code class="inline">{0,0}</code> is because of the subexpression marked by the parentheses). As the length of the match is 0, we do not advance to the next position yet.</p>
<p>  At offset <code class="inline">0</code> with <code class="inline">[anchored, notempty_atstart]</code>   *  The search is retried with options <code class="inline">[anchored, notempty_atstart]</code> at the same position, which does not give any interesting result of longer length, so the search position is advanced to the next character (<code class="inline">a</code>).</p>
<p>  At offset <code class="inline">1</code>   *  The search results in <code class="inline">[{1,0},{1,0}]</code>, so this search is also repeated with the extra options.</p>
<p>  At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code>   *  Alternative <code class="inline">ab</code> is found and the result is [{1,2},{1,2}]. The result is added to the list of results and the position in the search string is advanced two steps.</p>
<p>  At offset <code class="inline">3</code>   *  The search once again matches the empty string, giving <code class="inline">[{3,0},{3,0}]</code>.</p>
<p>  At offset <code class="inline">1</code> with <code class="inline">[anchored, notempty_atstart]</code>   *  This gives no result of length &gt; 0 and we are at the last position, so the global search is complete.</p>
<p>   The result of the call is:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="9643173141-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="9643173141-2">[</span><span class="p" data-group-id="9643173141-3">[</span><span class="p" data-group-id="9643173141-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-4">}</span><span class="p">,</span><span class="p" data-group-id="9643173141-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-5">}</span><span class="p" data-group-id="9643173141-3">]</span><span class="p">,</span><span class="p" data-group-id="9643173141-6">[</span><span class="p" data-group-id="9643173141-7">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-7">}</span><span class="p">,</span><span class="p" data-group-id="9643173141-8">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-8">}</span><span class="p" data-group-id="9643173141-6">]</span><span class="p">,</span><span class="p" data-group-id="9643173141-9">[</span><span class="p" data-group-id="9643173141-10">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="9643173141-10">}</span><span class="p">,</span><span class="p" data-group-id="9643173141-11">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="9643173141-11">}</span><span class="p" data-group-id="9643173141-9">]</span><span class="p">,</span><span class="p" data-group-id="9643173141-12">[</span><span class="p" data-group-id="9643173141-13">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-13">}</span><span class="p">,</span><span class="p" data-group-id="9643173141-14">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="9643173141-14">}</span><span class="p" data-group-id="9643173141-12">]</span><span class="p" data-group-id="9643173141-2">]</span><span class="p" data-group-id="9643173141-1">}</span></code></pre>
<p>  <code class="inline">notempty</code>   *  An empty string is not considered to be a valid match if this option is specified. If alternatives in the pattern exist, they are tried. If all the alternatives match the empty string, the entire match fails.</p>
<p> Example:</p>
<p> If the following pattern is applied to a string not beginning with &quot;a&quot; or &quot;b&quot;, it would normally match the empty string at the start of the subject:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">a?</span><span class="n">b?</span></code></pre>
<p> With option <code class="inline">notempty</code>, this match is invalid, so <a href="#run/3"><code class="inline">run/3</code></a> searches further into the string for occurrences of &quot;a&quot; or &quot;b&quot;.</p>
<p>  <code class="inline">notempty_atstart</code>   *  Like <code class="inline">notempty</code>, except that an empty string match that is not at the start of the subject is permitted. If the pattern is anchored, such a match can occur only if the pattern contains \K.</p>
<p> Perl has no direct equivalent of <code class="inline">notempty</code> or <code class="inline">notempty_atstart</code>, but it does make a special case of a pattern match of the empty string within its split() function, and when using modifier <code class="inline">/g</code>. The Perl behavior can be emulated after matching a null string by first trying the match again at the same offset with <code class="inline">notempty_atstart</code> and <code class="inline">anchored</code>, and then, if that fails, by advancing the starting offset (see below) and trying an ordinary match again.</p>
<p>  <code class="inline">notbol</code>   *  Specifies that the first character of the subject string is not the beginning of a line, so the circumflex metacharacter is not to match before it. Setting this without <code class="inline">multiline</code> (at compile time) causes circumflex never to match. This option only affects the behavior of the circumflex metacharacter. It does not affect \A.</p>
<p>  <code class="inline">noteol</code>   *  Specifies that the end of the subject string is not the end of a line, so the dollar metacharacter is not to match it nor (except in multiline mode) a newline immediately before it. Setting this without <code class="inline">multiline</code> (at compile time) causes dollar never to match. This option affects only the behavior of the dollar metacharacter. It does not affect \Z or \z.</p>
<p>  <code class="inline">report_errors</code>   *  Gives better control of the error handling in <a href="#run/3"><code class="inline">run/3</code></a>. When specified, compilation errors (if the regular expression is not already compiled) and runtime errors are explicitly returned as an error tuple.</p>
<p> The following are the possible runtime errors:</p>
<p>  <code class="inline">match_limit</code>   *  The PCRE library sets a limit on how many times the internal match function can be called. Defaults to 10,000,000 in the library compiled for Erlang. If <code class="inline">{error, match_limit}</code> is returned, the execution of the regular expression has reached this limit. This is normally to be regarded as a <code class="inline">nomatch</code>, which is the default return value when this occurs, but by specifying <code class="inline">report_errors</code>, you are informed when the match fails because of too many internal calls.</p>
<p>  <code class="inline">match_limit_recursion</code>   *  This error is very similar to <code class="inline">match_limit</code>, but occurs when the internal match function of PCRE is &quot;recursively&quot; called more times than the <code class="inline">match_limit_recursion</code> limit, which defaults to 10,000,000 as well. Notice that as long as the <code class="inline">match_limit</code> and <code class="inline">match_limit_default</code> values are kept at the default values, the <code class="inline">match_limit_recursion</code> error cannot occur, as the <code class="inline">match_limit</code> error occurs before that (each recursive call is also a call, but not conversely). Both limits can however be changed, either by setting limits directly in the regular expression string (see section PCRE Regular Eexpression Details) or by specifying options to <a href="#run/3"><code class="inline">run/3</code></a>.</p>
<p>   It is important to understand that what is referred to as &quot;recursion&quot; when limiting matches is not recursion on the C stack of the Erlang machine or on the Erlang process stack. The PCRE version compiled into the Erlang VM uses machine &quot;heap&quot; memory to store values that must be kept over recursion in regular expression matches.</p>
<p>  <code class="inline">{match_limit, integer() &gt;= 0}</code>   *  Limits the execution time of a match in an implementation-specific way. It is described as follows by the PCRE documentation:</p>
<pre><code class="nohighlight makeup elixir"><span class="nc">The</span><span class="w"> </span><span class="n">match_limit</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">provides</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">means</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">preventing</span><span class="w"> </span><span class="nc">PCRE</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">using</span><span class="w">
</span><span class="n">up</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">vast</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">resources</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="n">patterns</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">going</span><span class="w">
</span><span class="n">to</span><span class="w"> </span><span class="n">match</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">very</span><span class="w"> </span><span class="n">large</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">possibilities</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">their</span><span class="w">
</span><span class="n">search</span><span class="w"> </span><span class="n">trees</span><span class="o">.</span><span class="w"> </span><span class="nc">The</span><span class="w"> </span><span class="n">classic</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">pattern</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">nested</span><span class="w">
</span><span class="n">unlimited</span><span class="w"> </span><span class="n">repeats</span><span class="o">.</span><span class="w">

</span><span class="nc">Internally</span><span class="p">,</span><span class="w"> </span><span class="n">pcre_exec</span><span class="p" data-group-id="8970759847-1">(</span><span class="p" data-group-id="8970759847-1">)</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">match</span><span class="p" data-group-id="8970759847-2">(</span><span class="p" data-group-id="8970759847-2">)</span><span class="p">,</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">calls</span><span class="w">
</span><span class="n">repeatedly</span><span class="w"> </span><span class="p" data-group-id="8970759847-3">(</span><span class="n">sometimes</span><span class="w"> </span><span class="n">recursively</span><span class="p" data-group-id="8970759847-3">)</span><span class="o">.</span><span class="w"> </span><span class="nc">The</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">match_limit</span><span class="w"> </span><span class="n">is</span><span class="w">
</span><span class="n">imposed</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">called</span><span class="w"> </span><span class="n">during</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">match</span><span class="p">,</span><span class="w">
</span><span class="n">which</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">effect</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">limiting</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">backtracking</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">can</span><span class="w">
</span><span class="n">take</span><span class="w"> </span><span class="n">place</span><span class="o">.</span><span class="w"> </span><span class="nc">For</span><span class="w"> </span><span class="n">patterns</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">anchored</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="n">restarts</span><span class="w">
</span><span class="n">from</span><span class="w"> </span><span class="n">zero</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="n">string</span><span class="o">.</span></code></pre>
<p> This means that runaway regular expression matches can fail faster if the limit is lowered using this option. The default value 10,000,000 is compiled into the Erlang VM.</p>
<p>  This option does in no way affect the execution of the Erlang VM in terms of &quot;long running BIFs&quot;. <a href="#run/3"><code class="inline">run/3</code></a> always gives control back to the scheduler of Erlang processes at intervals that ensures the real-time properties of the Erlang system.</p>
<p>   <code class="inline">{match_limit_recursion, integer() &gt;= 0}</code>   *  Limits the execution time and memory consumption of a match in an implementation-specific way, very similar to <code class="inline">match_limit</code>. It is described as follows by the PCRE documentation:</p>
<pre><code class="nohighlight makeup elixir"><span class="nc">The</span><span class="w"> </span><span class="n">match_limit_recursion</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">similar</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">match_limit</span><span class="p">,</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">instead</span><span class="w">
</span><span class="n">of</span><span class="w"> </span><span class="n">limiting</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">times</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">match</span><span class="p" data-group-id="9272975800-1">(</span><span class="p" data-group-id="9272975800-1">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">called</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="w">
</span><span class="n">limits</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">recursion</span><span class="o">.</span><span class="w"> </span><span class="nc">The</span><span class="w"> </span><span class="n">recursion</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="n">number</span><span class="w">
</span><span class="n">than</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">calls</span><span class="p">,</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">match</span><span class="p" data-group-id="9272975800-2">(</span><span class="p" data-group-id="9272975800-2">)</span><span class="w"> </span><span class="n">are</span><span class="w">
</span><span class="n">recursive</span><span class="o">.</span><span class="w"> </span><span class="nc">This</span><span class="w"> </span><span class="n">limit</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="n">than</span><span class="w">
</span><span class="n">match_limit</span><span class="o">.</span><span class="w">

</span><span class="nc">Limiting</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">recursion</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="n">limits</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">that</span><span class="w">
</span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="p">,</span><span class="w"> </span><span class="ow">or</span><span class="p">,</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="nc">PCRE</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="kn">use</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">heap</span><span class="w">
</span><span class="n">instead</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">amount</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">heap</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">used</span><span class="o">.</span></code></pre>
<p> The Erlang VM uses a PCRE library where heap memory is used when regular expression match recursion occurs. This therefore limits the use of machine heap, not C stack.</p>
<p> Specifying a lower value can result in matches with deep recursion failing, when they should have matched:</p>
<pre><code class="nohighlight makeup elixir"><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="7992653662-1">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p" data-group-id="7992653662-1">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7992653662-2">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="7992653662-3">[</span><span class="p" data-group-id="7992653662-4">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">14</span><span class="p" data-group-id="7992653662-4">}</span><span class="p">,</span><span class="p" data-group-id="7992653662-5">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">13</span><span class="p" data-group-id="7992653662-5">}</span><span class="p" data-group-id="7992653662-3">]</span><span class="p" data-group-id="7992653662-2">}</span><span class="w">
</span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="7992653662-6">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="7992653662-7">[</span><span class="p" data-group-id="7992653662-8">{</span><span class="n">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="7992653662-8">}</span><span class="p" data-group-id="7992653662-7">]</span><span class="p" data-group-id="7992653662-6">)</span><span class="o">.</span><span class="w">
</span><span class="n">nomatch</span><span class="w">
</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="7992653662-9">(</span><span class="s">&quot;aaaaaaaaaaaaaz&quot;</span><span class="p">,</span><span class="s">&quot;(a+)*z&quot;</span><span class="p">,</span><span class="p" data-group-id="7992653662-10">[</span><span class="p" data-group-id="7992653662-11">{</span><span class="n">match_limit_recursion</span><span class="p">,</span><span class="mi">5</span><span class="p" data-group-id="7992653662-11">}</span><span class="p">,</span><span class="n">report_errors</span><span class="p" data-group-id="7992653662-10">]</span><span class="p" data-group-id="7992653662-9">)</span><span class="o">.</span><span class="w">
</span><span class="p" data-group-id="7992653662-12">{</span><span class="n">error</span><span class="p">,</span><span class="n">match_limit_recursion</span><span class="p" data-group-id="7992653662-12">}</span></code></pre>
<p> This option and option <code class="inline">match_limit</code> are only to be used in rare cases. Understanding of the PCRE library internals is recommended before tampering with these limits.</p>
<p>  <code class="inline">{offset, integer() &gt;= 0}</code>   *  Start matching at the offset (position) specified in the subject string. The offset is zero-based, so that the default is <code class="inline">{offset,0}</code> (all of the subject string).</p>
<p>  <code class="inline">{newline, ``NLSpec``}</code>   *  Overrides the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</p>
<p>  <code class="inline">cr</code>   *  Newline is indicated by a single character CR (ASCII 13).</p>
<p>  <code class="inline">lf</code>   *  Newline is indicated by a single character LF (ASCII 10), the default.</p>
<p>  <code class="inline">crlf</code>   *  Newline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence.</p>
<p>  <code class="inline">anycrlf</code>   *  Any of the three preceding sequences is be recognized.</p>
<p>  <code class="inline">any</code>   *  Any of the newline sequences above, and the Unicode sequences VT (vertical tab, U+000B), FF (formfeed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029).</p>
<pre><code class="nohighlight makeup elixir"><span class="err">`</span><span class="n">bsr_anycrlf</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w">  </span><span class="nc">Specifies</span><span class="w"> </span><span class="n">specifically</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="err">\</span><span class="nc">R</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">CR</span><span class="w"> </span><span class="nc">LF</span><span class="p">,</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="nc">CRLF</span><span class="w"> </span><span class="n">sequences</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nc">Unicode</span><span class="o">-</span><span class="n">specific</span><span class="w"> </span><span class="n">newline</span><span class="w"> </span><span class="n">characters</span><span class="o">.</span><span class="w"> </span><span class="p" data-group-id="6630174336-1">(</span><span class="nc">Overrides</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">compilation</span><span class="w"> </span><span class="n">option</span><span class="o">.</span><span class="p" data-group-id="6630174336-1">)</span></code></pre>
<p>  <code class="inline">bsr_unicode</code>   *  Specifies specifically that \R is to match all the Unicode newline characters (including CRLF, and so on, the default). (Overrides the compilation option.)</p>
<p>  <code class="inline">{capture, ``ValueSpec``}</code>/<code class="inline">{capture, ``ValueSpec``, ``Type``}</code>   *  Specifies which captured substrings are returned and in what format. By default, <a href="#run/3"><code class="inline">run/3</code></a> captures all of the matching part of the substring and all capturing subpatterns (all of the pattern is automatically captured). The default return type is (zero-based) indexes of the captured parts of the string, specified as <code class="inline">{Offset,Length}</code> pairs (the <code class="inline">index</code> <code class="inline">Type</code> of capturing).</p>
<p> As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair <code class="inline">{3,4}</code>, where character positions are zero-based, just as in offsets:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="2271083822-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;abcd&quot;</span><span class="p">,</span><span class="p" data-group-id="2271083822-2">[</span><span class="p" data-group-id="2271083822-2">]</span><span class="p" data-group-id="2271083822-1">)</span><span class="o">.</span></code></pre>
<p> The return value of this call is:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="9797230270-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="9797230270-2">[</span><span class="p" data-group-id="9797230270-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="9797230270-3">}</span><span class="p" data-group-id="9797230270-2">]</span><span class="p" data-group-id="9797230270-1">}</span></code></pre>
<p> Another (and quite common) case is where the regular expression matches all of the subject:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="5338721038-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*abcd.*&quot;</span><span class="p">,</span><span class="p" data-group-id="5338721038-2">[</span><span class="p" data-group-id="5338721038-2">]</span><span class="p" data-group-id="5338721038-1">)</span><span class="o">.</span></code></pre>
<p> Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="4452973132-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="4452973132-2">[</span><span class="p" data-group-id="4452973132-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="4452973132-3">}</span><span class="p" data-group-id="4452973132-2">]</span><span class="p" data-group-id="4452973132-1">}</span></code></pre>
<p> If the regular expression contains capturing subpatterns, like in:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="0403341966-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="0403341966-2">[</span><span class="p" data-group-id="0403341966-2">]</span><span class="p" data-group-id="0403341966-1">)</span><span class="o">.</span></code></pre>
<p> all of the matched subject is captured, as well as the captured substrings:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="0354554042-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="0354554042-2">[</span><span class="p" data-group-id="0354554042-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="0354554042-3">}</span><span class="p">,</span><span class="p" data-group-id="0354554042-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="0354554042-4">}</span><span class="p" data-group-id="0354554042-2">]</span><span class="p" data-group-id="0354554042-1">}</span></code></pre>
<p> The complete matching pattern always gives the first return value in the list and the remaining subpatterns are added in the order they occurred in the regular expression.</p>
<p> The capture tuple is built up as follows:</p>
<p>  <code class="inline">ValueSpec</code>   *  Specifies which captured (sub)patterns are to be returned. <code class="inline">ValueSpec</code> can either be an atom describing a predefined set of return values, or a list containing the indexes or the names of specific subpatterns to return.</p>
<p> The following are the predefined sets of subpatterns:</p>
<p>  <code class="inline">all</code>   *  All captured subpatterns including the complete matching string. This is the default.</p>
<p>  <code class="inline">all_names</code>   *  All named subpatterns in the regular expression, as if a <code class="inline">list()</code> of all the names in alphabetical order was specified. The list of all names can also be retrieved with  <a href="#inspect/2"><code class="inline">inspect/2</code></a>.</p>
<p>  <code class="inline">first</code>   *  Only the first captured subpattern, which is always the complete matching part of the subject. All explicitly captured subpatterns are discarded.</p>
<p>  <code class="inline">all_but_first</code>   *  All but the first matching subpattern, that is, all explicitly captured subpatterns, but not the complete matching part of the subject string. This is useful if the regular expression as a whole matches a large part of the subject, but the part you are interested in is in an explicitly captured subpattern. If the return type is <code class="inline">list</code> or <code class="inline">binary</code>, not returning subpatterns you are not interested in is a good way to optimize.</p>
<p>  <code class="inline">none</code>   *  Returns no matching subpatterns, gives the single atom <code class="inline">match</code> as the return value of the function when matching successfully instead of the <code class="inline">{match, list()}</code> return. Specifying an empty list gives the same behavior.</p>
<p>   The value list is a list of indexes for the subpatterns to return, where index 0 is for all of the pattern, and 1 is for the first explicit capturing subpattern in the regular expression, and so on. When using named captured subpatterns (see below) in the regular expression, one can use <code class="inline">atom()</code>s or <code class="inline">string()</code>s to specify the subpatterns to be returned. For example, consider the regular expression:</p>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;.*(abcd).*&quot;</span></code></pre>
<p> matched against string &quot;ABCabcdABC&quot;, capturing only the &quot;abcd&quot; part (the first explicit subpattern):</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="6593545232-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="6593545232-2">[</span><span class="p" data-group-id="6593545232-3">{</span><span class="n">capture</span><span class="p">,</span><span class="p" data-group-id="6593545232-4">[</span><span class="mi">1</span><span class="p" data-group-id="6593545232-4">]</span><span class="p" data-group-id="6593545232-3">}</span><span class="p" data-group-id="6593545232-2">]</span><span class="p" data-group-id="6593545232-1">)</span><span class="o">.</span></code></pre>
<p> The call gives the following result, as the first explicitly captured subpattern is &quot;(abcd)&quot;, matching &quot;abcd&quot; in the subject, at (zero-based) position 3, of length 4:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="5057025414-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="5057025414-2">[</span><span class="p" data-group-id="5057025414-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="5057025414-3">}</span><span class="p" data-group-id="5057025414-2">]</span><span class="p" data-group-id="5057025414-1">}</span></code></pre>
<p> Consider the same regular expression, but with the subpattern explicitly named &#39;FOO&#39;:</p>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span></code></pre>
<p> With this expression, we could still give the index of the subpattern with the following call:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="2134863995-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="2134863995-2">[</span><span class="p" data-group-id="2134863995-3">{</span><span class="n">capture</span><span class="p">,</span><span class="p" data-group-id="2134863995-4">[</span><span class="mi">1</span><span class="p" data-group-id="2134863995-4">]</span><span class="p" data-group-id="2134863995-3">}</span><span class="p" data-group-id="2134863995-2">]</span><span class="p" data-group-id="2134863995-1">)</span><span class="o">.</span></code></pre>
<p> giving the same result as before. But, as the subpattern is named, we can also specify its name in the value list:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="9376950806-1">(</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p">,</span><span class="s">&quot;.*(?&lt;FOO&gt;abcd).*&quot;</span><span class="p">,</span><span class="p" data-group-id="9376950806-2">[</span><span class="p" data-group-id="9376950806-3">{</span><span class="n">capture</span><span class="p">,</span><span class="p" data-group-id="9376950806-4">[</span><span class="sc">&#39;FOO&#39;</span><span class="p" data-group-id="9376950806-4">]</span><span class="p" data-group-id="9376950806-3">}</span><span class="p" data-group-id="9376950806-2">]</span><span class="p" data-group-id="9376950806-1">)</span><span class="o">.</span></code></pre>
<p> This would give the same result as the earlier examples, namely:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="8942980704-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="8942980704-2">[</span><span class="p" data-group-id="8942980704-3">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="8942980704-3">}</span><span class="p" data-group-id="8942980704-2">]</span><span class="p" data-group-id="8942980704-1">}</span></code></pre>
<p> The values list can specify indexes or names not present in the regular expression, in which case the return values vary depending on the type. If the type is <code class="inline">index</code>, the tuple <code class="inline">{-1,0}</code> is returned for values with no corresponding subpattern in the regular expression, but for the other types (<code class="inline">binary</code> and <code class="inline">list</code>), the values are the empty binary or list, respectively.</p>
<p>  <code class="inline">Type</code>   *  Optionally specifies how captured substrings are to be returned. If omitted, the default of <code class="inline">index</code> is used.</p>
<p> <code class="inline">Type</code> can be one of the following:</p>
<p>  <code class="inline">index</code>   *  Returns captured substrings as pairs of byte indexes into the subject string and length of the matching string in the subject (as if the subject string was flattened with  <code class="inline">erlang:iolist_to_binary/1</code> or  <code class="inline">unicode:characters_to_binary/2</code> before matching). Notice that option <code class="inline">unicode</code> results in byte-oriented indexes in a (possibly virtual) UTF-8 encoded binary. A byte index tuple <code class="inline">{0,2}</code> can therefore represent one or two characters when <code class="inline">unicode</code> is in effect. This can seem counter-intuitive, but has been deemed the most effective and useful way to do it. To return lists instead can result in simpler code if that is desired. This return type is the default.</p>
<p>  <code class="inline">list</code>   *  Returns matching substrings as lists of characters (Erlang <code class="inline">string()</code>s). It option <code class="inline">unicode</code> is used in combination with the \C sequence in the regular expression, a captured subpattern can contain bytes that are not valid UTF-8 (\C matches bytes regardless of character encoding). In that case the <code class="inline">list</code> capturing can result in the same types of tuples that  <code class="inline">unicode:characters_to_list/2</code> can return, namely three-tuples with tag <code class="inline">incomplete</code> or <code class="inline">error</code>, the successfully converted characters and the invalid UTF-8 tail of the conversion as a binary. The best strategy is to avoid using the \C sequence when capturing lists.</p>
<p>  <code class="inline">binary</code>   *  Returns matching substrings as binaries. If option <code class="inline">unicode</code> is used, these binaries are in UTF-8. If the \C sequence is used together with <code class="inline">unicode</code>, the binaries can be invalid UTF-8.</p>
<pre><code class="nohighlight makeup elixir"><span class="w"> </span><span class="nc">In</span><span class="w"> </span><span class="n">general</span><span class="p">,</span><span class="w"> </span><span class="n">subpatterns</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">assigned</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">match</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="err">`</span><span class="p" data-group-id="5148454006-1">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="5148454006-1">}</span><span class="err">`</span><span class="w"> </span><span class="ow">when</span><span class="w"> </span><span class="err">`</span><span class="n">type</span><span class="err">`</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="err">`</span><span class="n">index</span><span class="err">`</span><span class="o">.</span><span class="w"> </span><span class="nc">Unassigned</span><span class="w"> </span><span class="n">subpatterns</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">returned</span><span class="w"> </span><span class="n">as</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="n">respectively</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">return</span><span class="w"> </span><span class="n">types</span><span class="o">.</span><span class="w"> </span><span class="nc">Consider</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">following</span><span class="w"> </span><span class="n">regular</span><span class="w"> </span><span class="n">expression</span><span class="p">:</span></code></pre>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;.*((?&lt;FOO&gt;abdd)|a(..d)).*&quot;</span></code></pre>
<p> There are three explicitly capturing subpatterns, where the opening parenthesis position determines the order in the result, hence <code class="inline">((?&lt;FOO&gt;abdd)|a(..d))</code> is subpattern index 1, <code class="inline">(?&lt;FOO&gt;abdd)</code> is subpattern index 2, and <code class="inline">(..d)</code> is subpattern index 3. When matched against the following string:</p>
<pre><code class="nohighlight makeup elixir"><span class="s">&quot;ABCabcdABC&quot;</span></code></pre>
<p> the subpattern at index 2 does not match, as &quot;abdd&quot; is not present in the string, but the complete pattern matches (because of the alternative <code class="inline">a(..d)</code>). The subpattern at index 2 is therefore unassigned and the default return value is:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="3955619482-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="3955619482-2">[</span><span class="p" data-group-id="3955619482-3">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p" data-group-id="3955619482-3">}</span><span class="p">,</span><span class="p" data-group-id="3955619482-4">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="3955619482-4">}</span><span class="p">,</span><span class="p" data-group-id="3955619482-5">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p" data-group-id="3955619482-5">}</span><span class="p">,</span><span class="p" data-group-id="3955619482-6">{</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p" data-group-id="3955619482-6">}</span><span class="p" data-group-id="3955619482-2">]</span><span class="p" data-group-id="3955619482-1">}</span></code></pre>
<p> Setting the capture <code class="inline">Type</code> to <code class="inline">binary</code> gives:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="1206593602-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="1206593602-2">[</span><span class="p" data-group-id="1206593602-3">&lt;&lt;</span><span class="s">&quot;ABCabcdABC&quot;</span><span class="p" data-group-id="1206593602-3">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="1206593602-4">&lt;&lt;</span><span class="s">&quot;abcd&quot;</span><span class="p" data-group-id="1206593602-4">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="1206593602-5">&lt;&lt;</span><span class="p" data-group-id="1206593602-5">&gt;&gt;</span><span class="p">,</span><span class="p" data-group-id="1206593602-6">&lt;&lt;</span><span class="s">&quot;bcd&quot;</span><span class="p" data-group-id="1206593602-6">&gt;&gt;</span><span class="p" data-group-id="1206593602-2">]</span><span class="p" data-group-id="1206593602-1">}</span></code></pre>
<p> Here the empty binary (<code class="inline">&lt;&lt;&gt;&gt;</code>) represents the unassigned subpattern. In the <code class="inline">binary</code> case, some information about the matching is therefore lost, as <code class="inline">&lt;&lt;&gt;&gt;</code> can also be an empty string captured.</p>
<p> If differentiation between empty matches and non-existing subpatterns is necessary, use the <code class="inline">type</code> <code class="inline">index</code> and do the conversion to the final type in Erlang code.</p>
<p> When option <code class="inline">global</code> is speciified, the <code class="inline">capture</code> specification affects each match separately, so that:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:run</span><span class="p" data-group-id="0423932891-1">(</span><span class="s">&quot;cacb&quot;</span><span class="p">,</span><span class="s">&quot;c(a|b)&quot;</span><span class="p">,</span><span class="p" data-group-id="0423932891-2">[</span><span class="n">global</span><span class="p">,</span><span class="p" data-group-id="0423932891-3">{</span><span class="n">capture</span><span class="p">,</span><span class="p" data-group-id="0423932891-4">[</span><span class="mi">1</span><span class="p" data-group-id="0423932891-4">]</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="0423932891-3">}</span><span class="p" data-group-id="0423932891-2">]</span><span class="p" data-group-id="0423932891-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="0345923283-1">{</span><span class="n">match</span><span class="p">,</span><span class="p" data-group-id="0345923283-2">[</span><span class="p" data-group-id="0345923283-3">[</span><span class="s">&quot;a&quot;</span><span class="p" data-group-id="0345923283-3">]</span><span class="p">,</span><span class="p" data-group-id="0345923283-4">[</span><span class="s">&quot;b&quot;</span><span class="p" data-group-id="0345923283-4">]</span><span class="p" data-group-id="0345923283-2">]</span><span class="p" data-group-id="0345923283-1">}</span></code></pre>
<p>   For a descriptions of options only affecting the compilation step, see <a href="#compile/2"><code class="inline">compile/2</code></a>.</p>
  </section>
</section>
<section class="detail" id="split/2">
  <div class="detail-header">
    <a href="#split/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">split/2</h1>
      <div class="specs">
          <pre>split(Subject, RE) -> SplitList
         when
             Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
             RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>(),
             SplitList :: [<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>()].
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Same as <code class="inline">split(``Subject``, ``RE``, [])</code>.</p>
  </section>
</section>
<section class="detail" id="split/3">
  <div class="detail-header">
    <a href="#split/3" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">split/3</h1>
      <div class="specs">
          <pre>split(Subject, RE, Options) -> SplitList
         when
             Subject :: <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
             RE :: mp() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>(),
             Options :: [Option],
             Option ::
                 anchored | notbol | noteol | notempty |
                 notempty_atstart |
                 {offset, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                 {newline, nl_spec()} |
                 {match_limit, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                 {match_limit_recursion, <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>()} |
                 bsr_anycrlf | bsr_unicode |
                 {return, ReturnType} |
                 {parts, NumParts} |
                 group | trim | CompileOpt,
             NumParts :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">non_neg_integer</a>() | infinity,
             ReturnType :: iodata | list | binary,
             CompileOpt :: compile_option(),
             SplitList :: [RetData] | [GroupedRetData],
             GroupedRetData :: [RetData],
             RetData ::
                 <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">iodata</a>() | unicode:<a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">charlist</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>() | <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">list</a>().
</pre>
      </div>
  </div>
  <section class="docstring">
<p> Splits the input into parts by finding tokens according to the regular expression supplied. The splitting is basically done by running a global regular expression match and dividing the initial string wherever a match occurs. The matching part of the string is removed from the output.</p>
<p> As in <a href="#run/3"><code class="inline">run/3</code></a>, an <code class="inline">mp()</code> compiled with option <code class="inline">unicode</code> requires <code class="inline">Subject</code> to be a Unicode <code class="inline">charlist()</code>. If compilation is done implicitly and the <code class="inline">unicode</code> compilation option is specified to this function, both the regular expression and <code class="inline">Subject</code> are to be specified as valid Unicode <code class="inline">charlist()</code>s.</p>
<p> The result is given as a list of &quot;strings&quot;, the preferred data type specified in option <code class="inline">return</code> (default <code class="inline">iodata</code>).</p>
<p> If subexpressions are specified in the regular expression, the matching subexpressions are returned in the resulting list as well. For example:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="6900059304-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[ln]&quot;</span><span class="p">,</span><span class="p" data-group-id="6900059304-2">[</span><span class="p" data-group-id="6900059304-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="6900059304-3">}</span><span class="p" data-group-id="6900059304-2">]</span><span class="p" data-group-id="6900059304-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="1274806459-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="1274806459-1">]</span></code></pre>
<p> while</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="2744351480-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="2744351480-2">[</span><span class="p" data-group-id="2744351480-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="2744351480-3">}</span><span class="p" data-group-id="2744351480-2">]</span><span class="p" data-group-id="2744351480-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="3159519253-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p">,</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="3159519253-1">]</span></code></pre>
<p> The text matching the subexpression (marked by the parentheses in the regular expression) is inserted in the result list where it was found. This means that concatenating the result of a split where the whole regular expression is a single subexpression (as in the last example) always results in the original string.</p>
<p> As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option <code class="inline">group</code>, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="6729729422-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;([ln])&quot;</span><span class="p">,</span><span class="p" data-group-id="6729729422-2">[</span><span class="p" data-group-id="6729729422-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="6729729422-3">}</span><span class="p">,</span><span class="n">group</span><span class="p" data-group-id="6729729422-2">]</span><span class="p" data-group-id="6729729422-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="8758822422-1">[</span><span class="p" data-group-id="8758822422-2">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;l&quot;</span><span class="p" data-group-id="8758822422-2">]</span><span class="p">,</span><span class="p" data-group-id="8758822422-3">[</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;n&quot;</span><span class="p" data-group-id="8758822422-3">]</span><span class="p">,</span><span class="p" data-group-id="8758822422-4">[</span><span class="s">&quot;g&quot;</span><span class="p" data-group-id="8758822422-4">]</span><span class="p" data-group-id="8758822422-1">]</span></code></pre>
<p> Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</p>
<p> By default, all parts of the string, including the empty strings, are returned from the function, for example:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="9514455889-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="9514455889-2">[</span><span class="p" data-group-id="9514455889-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="9514455889-3">}</span><span class="p" data-group-id="9514455889-2">]</span><span class="p" data-group-id="9514455889-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="0450316794-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p">,</span><span class="p" data-group-id="0450316794-2">[</span><span class="p" data-group-id="0450316794-2">]</span><span class="p" data-group-id="0450316794-1">]</span></code></pre>
<p> as the matching of the &quot;g&quot; in the end of the string leaves an empty rest, which is also returned. This behavior differs from the default behavior of the split function in Perl, where empty strings at the end are by default removed. To get the &quot;trimming&quot; default behavior of Perl, specify <code class="inline">trim</code> as an option:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="0402652869-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="0402652869-2">[</span><span class="p" data-group-id="0402652869-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="0402652869-3">}</span><span class="p">,</span><span class="n">trim</span><span class="p" data-group-id="0402652869-2">]</span><span class="p" data-group-id="0402652869-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="5249220167-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;an&quot;</span><span class="p" data-group-id="5249220167-1">]</span></code></pre>
<p> The &quot;trim&quot; option says; &quot;give me as many parts as possible except the empty ones&quot;, which sometimes can be useful. You can also specify how many parts you want, by specifying <code class="inline">{parts,</code>N<code class="inline">}</code>:</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="4679049768-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="4679049768-2">[</span><span class="p" data-group-id="4679049768-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="4679049768-3">}</span><span class="p">,</span><span class="p" data-group-id="4679049768-4">{</span><span class="n">parts</span><span class="p">,</span><span class="mi">2</span><span class="p" data-group-id="4679049768-4">}</span><span class="p" data-group-id="4679049768-2">]</span><span class="p" data-group-id="4679049768-1">)</span><span class="o">.</span></code></pre>
<p> gives</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="5435195583-1">[</span><span class="s">&quot;Er&quot;</span><span class="p">,</span><span class="s">&quot;ang&quot;</span><span class="p" data-group-id="5435195583-1">]</span></code></pre>
<p> Notice that the last part is &quot;ang&quot;, not &quot;an&quot;, as splitting was specified into two parts, and the splitting stops when enough parts are given, which is why the result differs from that of <code class="inline">trim</code>.</p>
<p> More than three parts are not possible with this indata, so</p>
<pre><code class="nohighlight makeup elixir"><span class="n">re</span><span class="ss">:split</span><span class="p" data-group-id="4245000024-1">(</span><span class="s">&quot;Erlang&quot;</span><span class="p">,</span><span class="s">&quot;[lg]&quot;</span><span class="p">,</span><span class="p" data-group-id="4245000024-2">[</span><span class="p" data-group-id="4245000024-3">{</span><span class="n">return</span><span class="p">,</span><span class="n">list</span><span class="p" data-group-id="4245000024-3">}</span><span class="p">,</span><span class="p" data-group-id="4245000024-4">{</span><span class="n">parts</span><span class="p">,</span><span class="mi">4</span><span class="p" data-group-id="4245000024-4">}</span><span class="p" data-group-id="4245000024-2">]</span><span class="p" data-group-id="4245000024-1">)</span><span class="o">.</span></code></pre>
<p> gives the same result as the default, which is to be viewed as &quot;an infinite number of parts&quot;.</p>
<p> Specifying <code class="inline">0</code> as the number of parts gives the same effect as option <code class="inline">trim</code>. If subexpressions are captured, empty subexpressions matched at the end are also stripped from the result if <code class="inline">trim</code> or <code class="inline">{parts,0}</code> is specified.</p>
<p> The <code class="inline">trim</code> behavior corresponds exactly to the Perl default. <code class="inline">{parts,N}</code>, where N is a positive integer, corresponds exactly to the Perl behavior with a positive numerical third parameter. The default behavior of <a href="#split/3"><code class="inline">split/3</code></a> corresponds to the Perl behavior when a negative integer is specified as the third parameter for the Perl routine.</p>
<p> Summary of options not previously described for function <a href="#run/3"><code class="inline">run/3</code></a>:</p>
<p>  <code class="inline">{return,``ReturnType``}</code>   *  Specifies how the parts of the original string are presented in the result list. Valid types:</p>
<p>  <code class="inline">iodata</code>   *  The variant of <code class="inline">iodata()</code> that gives the least copying of data with the current implementation (often a binary, but do not depend on it).</p>
<p> <code class="inline">binary</code>   *  All parts returned as binaries.</p>
<p> <code class="inline">list</code>   *  All parts returned as lists of characters (&quot;strings&quot;).</p>
<pre><code class="nohighlight makeup elixir"><span class="err">`</span><span class="n">group</span><span class="err">`</span><span class="w">   </span><span class="o">*</span><span class="w">  </span><span class="nc">Groups</span><span class="w"> </span><span class="n">together</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">parts</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">subexpressions</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">regular</span><span class="w"> </span><span class="n">expression</span><span class="o">.</span></code></pre>
<p> The return value from the function is in this case a <code class="inline">list()</code> of <code class="inline">list()</code>s. Each sublist begins with the string picked out of the subject string, followed by the parts matching each of the subexpressions in order of occurrence in the regular expression.</p>
<p>  <code class="inline">{parts,N}</code>   *  Specifies the number of parts the subject string is to be split into.</p>
<p> The number of parts is to be a positive integer for a specific maximum number of parts, and <code class="inline">infinity</code> for the maximum number of parts possible (the default). Specifying <code class="inline">{parts,0}</code> gives as many parts as possible disregarding empty parts at the end, the same as specifying <code class="inline">trim</code>.</p>
<p>  <code class="inline">trim</code>   *  Specifies that empty parts at the end of the result list are to be disregarded. The same as specifying <code class="inline">{parts,0}</code>. This corresponds to the default behavior of the <code class="inline">split</code> built-in function in Perl.</p>
  </section>
</section>
<section class="detail" id="version/0">
  <div class="detail-header">
    <a href="#version/0" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature">version/0</h1>
      <div class="specs">
          <pre>version() -> <a href="https://hexdocs.pm/elixir/typespecs.html#built-in-types">binary</a>().
</pre>
      </div>
  </div>
  <section class="docstring">
<p> The return of this function is a string with the PCRE version of the system that was used in the Erlang/OTP compilation.</p>
  </section>
</section>
          </div>
        </section>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.21.2),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>
          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button tooltips-toggle">
            <span class="tooltips-option-disable">Disable tooltips</span>
            <span class="tooltips-option-enable">Enable tooltips</span>
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  </body>
</html>
